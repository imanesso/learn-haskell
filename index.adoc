= Learn Haskell 
:author: Anessollah Ima
:email: https://github.com/imanesso[@imanesso]
v1.0, 2020-09-01
// settings:
//:source-highlighter: rouge
:source-language: java,haskell
:language: {source-language}
:title: learn haskell
:toc: left
:toc-title:
:toclevels: 2
:sectnums:
:sectnumlevels: 5
:sourcedir: ../src/
:imagesdir: ./assets/images
:iconsdir: ./icons
:stylesdir: ./styles
:homepage: https://github.com/imanesso/learn-haskell


toc::[]


Das Ziel dieses Dokuments ist es, zusammenzufassen, was ich über funktionale Programmierung in Haskell gelernt habe. Später soll es mir als Nachschlagewerk dienen, aber es kann auch als Tutorial verstanden werden für Programmierer, die eher imperative Sprachen kennen.

== Einführung

=== Wieso Funktionale Programmierung?

Funktionale Programmierung ermöglicht es, kurzen deklarativen Programmcode zu schreiben, welcher nur Daten und Funktionen kennt und dafür keine Nebenwirkungen hat. Funktionen einer funktionalen Programmiersprache bekommen einen Input und generieren einen Output, der _nur_ vom Input abhängt und keine inneren Zustände kennt.

*Imperative Programmierung:*

[source,java]
----
var x; //Funktionen können mit den Daten machen, was sie wollen.

f();
g();
----


*Funktionale (deklarative) Programmierung:*
[source, haskell]
----
g(f x); --Daten werden in einem Funktionsfluss transformiert
----

Es gibt einen Programmfluss, welcher durch eine Verkettung von Funktionen ensteht. Die Funktionen sind wie Maschienen, welche mit einem Input einen Output generieren.

image::programmfluss.png[Programmfluss,500,250]

=== Wieso Haskell? 
//image::Haskell-Logo.svg[Haskell,25,25]

Die Funktionale Programmierung ist ein Programmierparadigma, dessen Konzepte auch in bekannten objektorientierten Programmiersprachen wie C# oder Java eingesetzt wird. Haskell ist aber eine pure funktionale Sprache, welche von Grund auf funktional designt wurde. Daher ist sie bestens dafür geeignet, das funktionale Programmieren kompromisslos zu lernen.

=== Setup

*Download der Haskell Plattform:* +
https://www.haskell.org/platform/

Nach der Installation kann in der Kommandozeile `ghci` gestartet werden. GHCI ist die interaktive Umgebung des Haskell Compilers GHC.

Wenn `ghci` gestartet wurde, dann man bereits in der Konsole programmieren, wie mit der `jshell` in Java.

Um Skripte mit dem `.hs` Format zu schreiben, welche man dann kompilieren und ausführen kann, sollte man die folgenden Befehle kennen:

[cols="1,2", options="header"] 
.GHCI Befehle
|===
|Befehl
|Beschreibung

|:?
| Zeigt Hilfstext

|:cd /path/..
|Ändert den Pfad

|:l skript.hs
|Lädt das Skript `skript.hs`

|:r 
|Lädt das aktuelle Skript neu

|:t expr
|Zeigt den Typ einer Expression

|:q
|Beendet die `ghci` Sitzung
|===



== Funktionsdefinition
Um Funktionen definieren zu können, braucht man in Haskell einen Funktionsnamen, Parametertypen und einen Rückgabetyp.

//image::funktionsdefinition.png[Funktionsdefinition,500,250]

[source,haskell]
----
name :: ParameterType1 -> ParameterType2 -> ... -> ParameterTypeK -> ResultType
name p1 p2 ... pk = e --Result based on parameters
----

*Beispiele*

[source,haskell]
----
verdoppeln :: Integer -> Integer
verdoppeln n = 2*n

addieren :: Integer -> Integer -> Integer
addieren a b = a + b
----

Vergleich mit Java

[source,java]
----
int verdoppeln(int n){
    return 2*n;
}

int addieren(int a, int b){
    return a+b;
}
----

== Typen

=== Was ist ein Typ
Daten sind einfach eine Menge von Bits, welche ohne korrekte Interpretation nutzlos sind. Typen geben diesen einfachen Bits Bedeutung.

Typen stellen sicher, dass auf den Werten von Variablen keine Operationen ausgeführt werden, die syntaktisch oder semantisch fehlerhaft sind und dass diese Werte im definierten Wertebereich sind.

Haskell hat wie Java ein *statisches Typsystem*. JS und Python haben ein dynamisches Typsystem, welches die Typen erst zur Laufzeit prüft.

In der Praxis ist es z. T überraschend, wie die Sprachen Ausdrücke interpretieren:

[cols="2,1,1,1,1", options="header"] 
.Typenvergleich
|===
|Ausdruck
|Javascript
|Python
|Java
|Haskell

|`5 + 8`
|`13`
|`13`
|`13`
|`13`

|`5 + "Hallo"`
|``"5Hallo"``
|[red]#Error#
|`"5Hallo"`
|[red]#Error#

|`5 + True`
|`6`
|`6`
|[red]#Error#
|[red]#Error#

|`5 - "2"`
|`3`
|[red]#Error#
|[red]#Error#
|[red]#Error#

|`5 * "1"`
|5
|`11111`
|[red]#Error#
|[red]#Error#

|`False * "Hallo"`
|`NaN`
|""
|[red]#Error#
|[red]#Error#
|===

=== Typen

==== Basic Types

[cols="1,1,1", options="header"] 
.Haskell Typen
|===
|Typ
|Beschreibung
|Wertebereich

|[blue]#Bool#
|Für logische Werte
|True oder False

|[blue]#Char#
|Für Zeichen
|Alle Zeichen

|[blue]#Int#
|Für ganzzahlige Integer
|64 Bit Integer, also -2^63 to 2^63-1

|[blue]#Integer#
|Für alle ganzzahligen Integer. Langsamer, da nicht CPU supportet.
|Kein fixer Wertebereich. Soviel, wie die CPU schafft.

|[blue]#Double#
|Für alle Gleitkommazahlen
|64 Bit Floating Point
|===