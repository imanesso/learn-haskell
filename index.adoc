= Learn Haskell 
:author: Anessollah Ima
:email: https://github.com/imanesso[@imanesso]
v1.0, 2020-09-01
// settings:
:source-highlighter: rouge
:source-language: java,haskell
:language: {source-language}
:title: learn haskell
:toc: left
:toc-title:
:toclevels: 2
:sectnums:
:sectnumlevels: 2
:sourcedir: ../src/
:imagesdir: ./assets/images
:iconsdir: ./icons
:stylesdir: ./styles
:homepage: https://github.com/imanesso/learn-haskell


toc::[]


Das Ziel dieses Dokuments ist es, zusammenzufassen, was ich über funktionale Programmierung in Haskell gelernt habe. Später soll es mir als Nachschlagewerk dienen, aber es kann auch als Tutorial verstanden werden für Programmierer, die eher imperative Sprachen kennen.

== Einführung

=== Wieso Funktionale Programmierung?

Funktionale Programmierung ermöglicht es, kurzen deklarativen Programmcode zu schreiben, welcher nur Daten und Funktionen kennt und dafür keine Nebenwirkungen hat. Funktionen einer funktionalen Programmiersprache bekommen einen Input und generieren einen Output, der _nur_ vom Input abhängt und keine inneren Zustände kennt.

*Imperative Programmierung:*

[source,java]
----
var x; //Funktionen können mit den Daten machen, was sie wollen.

f();
g();
----


*Funktionale (deklarative) Programmierung:*
[source, haskell]
----
g(f x); --Daten werden in einem Funktionsfluss transformiert
----

Es gibt einen Programmfluss, welcher durch eine Verkettung von Funktionen ensteht. Die Funktionen sind wie Maschienen, welche mit einem Input einen Output generieren.

image::programmfluss.png[Programmfluss,500,250]

=== Wieso Haskell? 
Die Funktionale Programmierung ist ein Programmierparadigma, dessen Konzepte auch in bekannten objektorientierten Programmiersprachen wie C# oder Java eingesetzt wird. Haskell ist aber eine pure funktionale Sprache, welche von Grund auf funktional designt wurde. Daher ist sie bestens dafür geeignet, das funktionale Programmieren kompromisslos zu lernen.

=== Setup

*Download der Haskell Plattform:* +
https://www.haskell.org/platform/

Nach der Installation kann in der Kommandozeile `ghci` gestartet werden. GHCI ist die interaktive Umgebung des Haskell Compilers GHC.

Wenn `ghci` gestartet wurde, dann man bereits in der Konsole programmieren, wie mit der `jshell` in Java.

Um Skripte mit dem `.hs` Format zu schreiben, welche man dann kompilieren und ausführen kann, sollte man die folgenden Befehle kennen:

[cols="1,2", options="header"] 
.GHCI Befehle
|===
|Befehl
|Beschreibung

|:?
| Zeigt Hilfstext

|:cd /path/..
|Ändert den Pfad

|:l skript.hs
|Lädt das Skript `skript.hs`

|:r 
|Lädt das aktuelle Skript neu

|:t expr
|Zeigt den Typ einer Expression

|:q
|Beendet die `ghci` Sitzung
|===


== Arithmetik und erste Funktionen
Wenn alles installiert ist, dann kann man bereits kleine Programme im Terminal schreiben, dafür muss man nur ghci starten  mit dem Befehl `ghci`. Dann kann man erste Funktionen, welche es bereits in Haskell gibt ausprobieren, wie z. B in der `jshell` in Java.

[source,terminal]
----
>ghci 5+5
10

>ghci 5==5
True

>ghci max 5 6 7
7
----

=== Erste Funktion
Um Funktionen definieren zu können, braucht man in Haskell einen Funktionsnamen, Parametertypen und einen Rückgabetyp.

[source,haskell]
----
name :: ParameterType1 -> ParameterType2 -> ... -> ParameterTypeK -> ResultType
name p1 p2 ... pk = p1 + pk + 1 --Result based on parameters
----

Sehr kleine Methoden kann man auch ohne Typdefinition schreiben, aber das führt schnell zu Fehler und ist nicht empfohlen.

*Beispiele*

[source,haskell]
----
verdoppeln :: Integer -> Integer
verdoppeln n = 2*n

addieren :: Integer -> Integer -> Integer
addieren a b = a + b
----

Vergleich mit Java

[source,java]
----
int verdoppeln(int n){
    return 2*n;
}

int addieren(int a, int b){
    return a+b;
}
----

*Funktionsaufruf*

Wenn man die `addieren` Funktion aufrufen möchte, dann kann man das in einem File wie `Mathe.hs` speichern.
Dieses File kann man in die ghci laden mit dem Befehl `ghci Mathe.hs`, wenn die ghci noch nicht gestartet ist oder `:l Mathe.hs`, wenn sie schon gestartet ist.

Wenn das File geladen wurde, dann kann man die Funktion mit den Parametern folgendermassen aufrufen 

[source,terminal]
----
>ghci addiere 5 5
10

>ghci verdopple 8
16
----

== Typen

=== Was ist ein Typ
Daten sind einfach eine Menge von Bits, welche ohne korrekte Interpretation nutzlos sind. Typen geben diesen einfachen Bits Bedeutung.

Typen stellen sicher, dass auf den Werten von Variablen keine Operationen ausgeführt werden, die syntaktisch oder semantisch fehlerhaft sind und dass diese Werte im definierten Wertebereich sind.

Haskell hat wie Java ein *statisches Typsystem*. JS und Python haben ein dynamisches Typsystem, welches die Typen erst zur Laufzeit prüft.

TIP: Mit `:t` kann man in der ghci den Typ eines Ausdrucks herausfinden. z. B `:t max`

In der Praxis ist es z. T überraschend, wie die Sprachen Ausdrücke interpretieren:

[cols="2,1,1,1,1", options="header"] 
.Typenvergleich
|===
|Ausdruck
|Javascript
|Python
|Java
|Haskell

|`5 + 8`
|`13`
|`13`
|`13`
|`13`

|`5 + "Hallo"`
|``"5Hallo"``
|[red]#Error#
|`"5Hallo"`
|[red]#Error#

|`5 + True`
|`6`
|`6`
|[red]#Error#
|[red]#Error#

|`5 - "2"`
|`3`
|[red]#Error#
|[red]#Error#
|[red]#Error#

|`5 * "1"`
|5
|`11111`
|[red]#Error#
|[red]#Error#

|`False * "Hallo"`
|`NaN`
|""
|[red]#Error#
|[red]#Error#
|===

=== Typen

==== Basic Types

[cols="1,1,1", options="header"] 
.Haskell Typen
|===
|Typ
|Beschreibung
|Wertebereich

|[blue]#Bool#
|Für logische Werte
|True oder False

|[blue]#Char#
|Für Zeichen
|Alle Zeichen

|[blue]#Int#
|Für ganzzahlige Integer
|64 Bit Integer, also -2^63 to 2^63-1

|[blue]#Integer#
|Für alle ganzzahligen Integer. Langsamer, da nicht CPU supportet.
|Kein fixer Wertebereich. Soviel, wie die CPU schafft.

|[blue]#Double#
|Für alle Gleitkommazahlen
|64 Bit Floating Point
|===

==== Enumeration Types
Mit `data` kann man Enumerationen erstellen

[source,haskell]
----
data Color = Red | Yellow | Green deriving (Show) <1>
data ToDo  = Stop | Wait | Go deriving (Show) <2>
----
<1> Enum mit 3 Farben
<2> Enum mit 3 Zuständen


NOTE: `deriving (Show)` macht, dass die Werte als `String` zurückgegeben werden können

==== Tuples
Tuples sind aggregierte Typen, welche eine endliche Sequenz von Komponenten mit unterschiedlichen Typen beinhaltet.

*Arity* nennt man die Anzahl Komponenten eines Tuples

[source,haskell]
----
(False, 8, "Hallo") <1>
(8, 'a', True, "Text") <2>
((True, `8`), (`e`, False, `x`)) <3>
----
<1> Das Tuple hat die Komponententypen `(Bool, Int, String)` und haben eine Arity von 3
<2> Das Tuple hat die Komponententypen `(Int, Char, Bool, String)` und haben eine Arity von 4
<3> Das Tuple hat zwei Tuple als Komponenten mit der Arity von 2

*Zugriff auf Tuple Komponenten* +
Zugreifen kann man mittels Pattern Matching. Darauf wird später eingegangen.

[source,haskell]
----
fstInt :: (Int,Int) -> Int 
fstInt (x, y) = x 

sndInt:: (Int,Int) -> Int
sndInt (x, y) = y
----

==== Polymorphe Typen
Die Funktionen `fstInt` und `sndInt` im letzten Teil funktionieren nur bei 2-Tuplen mit zwei `Int`. Um eine Funktion zu schreiben, welche für alle Typen funktioniert, benötigt man polymorphe Typen:

[source,haskell]
----
fst :: (a,b) -> a <1>
fst (x, y) = x 

snd:: (a,b) -> b
snd (x, y) = y
----
<1> `a` und `b` sind polymorphe Typen

Funktionen wie `fst` und `snd` nenn man *Polymorphe Funktionen*, da sie einen parametrischen Polymorphismus ermöglichen. Mit solchen Funktionen kann man weniger Code mit weniger Typfehleranfälligkeiten schreiben.

==== Typ Synonyme
Mit dem Schlüsselwort `type` kann man einen Typ Synonym erstellen. Dieser ist kein neuer Typ, sondern nur ein neuer Name!

[source,haskell]
----
type Coord = (Int, Int)
----
Hier kann zum Beispiel `Coord` gleich verwendet werden wie ein normales `(Int, Int)` Tuple. Es hilft nur der Leserlichkeit.

==== Record Types

Record Types sind neue eigene Typen die man definieren kann.

[source,haskell]
----
data Person = Person { name :: String , age :: Int } deriving (Show)
----

==== Function Types
Funktionen haben auch einen Typ. Es hat einen Typ für input parameter und für output parameter

[source,haskell]
----
functionname :: Inputtype -> Outputtype
----

==== Type classes

Typklassen sind vergleichbar mit Interfaces in Java oder C#. Wenn ein Typ Teil einer Typklasse ist, dann bedeutet das, dass gewisses Verhalten der Typklasse darin enthalten ist.

Einfach kann man das testen, wenn man in der ghci Typen von Operatoren anschaut.

NOTE: Alle Operatoren in Haskell sind auch Funktionen, welche infix geschrieben werden können. Wenn man in der ghci den Typ eines Operators anschaut, z. B `:t ==`, dann sieht man die Verwendung der Typklassen

Die `Eq` Typeklasse bietet eine Schnittstelle, um die Gleichheit der Elemente zu überprüfen. Alle Standart Typen in Haskell gehören zu dieser Typklasse.

Hier sind alle Standard-Typklassen in Haskell mit unterstützten Funktionen.

[source,terminal]
----
>ghci :t ==
(==) :: (Eq a) => a -> a -> Bool 
----

Basic Type Classes::
  Eq – equality types:::
    * Enthält Typen, deren Werte auf Gleichheit und Ungleichheit verglichen werden können
    * Methoden: `(==)`, `(/=)`
  Ord – ordered types:::
    * Enthält Typen, deren Werte vollständig geordnet sind
    * Methoden: `(<)`, `(<=)`, `(>)`, `(>=)`, `min`, `max`
  Show – showable types:::
    * Enthält Typen, deren Werte in Zeichenketten konvertiert werden können 
    * Methoden `show`
  Num – numeric types:::
    * Enthält Typen, deren Werte numerisch sind
    * Methoden: `(+)`, `(-)`, `(*)`, `negate`, `abs`, `signum`
  Integral – integral types:::
    * Enthält Typen, die numerisch sind, aber einen ganzzahligen Wert haben
    * Methoden: `div`, `mod`
  Fractional – fractional types:::
    * Enthält Typen, die numerisch, aber von gebrochenem Wert sind
    * Methoden: `(/)`, `recip`

*Berechnung mit Zahlen* +

Alle Zahlen gehören der Typklasse `Num` an. Dabei sieht die Hierarchie folgendermassen aus:

* `Num`
** `Integral` mit Typen `Int` und `Integer`
** `Fractional` mit dem Typ `Double`

CAUTION: Haskell konvertiert Zahlentypen nicht automatisch

Um Ganzzahlen zu konvertieren, gibt es die hilfreiche Methode: + 
 `fromIntegral :: (Integral a, Num b) => a -> b`

Die Methode `length` zum Beispiel gibt einen `Int` zurück, wenn man dazu `1.1` addieren möchte, dann benötigt man die Funktion `fromIntegral`

[source, haskell]
----
length [1,2,3,4]) + 1.1 <1>

fromIntegral (length [1,2,3,4]) + 1.1 <2>
----
<1> führt zu einem Fehler, da length einen `Int` zurückgibt und 1.1 ein `Double ist`

<2> `fromIntegral` löst das Problem

== Quellen
* http://learnyouahaskell.com/types-and-typeclasses
