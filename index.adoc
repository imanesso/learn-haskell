= Learn Haskell 
:author: Anessollah Ima
:email: https://github.com/imanesso[@imanesso]
v1.0, 2020-09-01
// settings:
//:source-highlighter: rouge
:source-language: java,haskell
:language: {source-language}
:title: learn haskell
:toc: left
:toc-title:
:toclevels: 2
:sectnums:
:sectnumlevels: 2
:sourcedir: ../src/
:imagesdir: ./assets/images
:icons: font
//:iconsdir: ./icons
:stylesdir: ./styles
:homepage: https://github.com/imanesso/learn-haskell


toc::[]


Das Ziel dieses Dokuments ist es, zusammenzufassen, was ich über funktionale Programmierung in Haskell gelernt habe. Später soll es mir als Nachschlagewerk dienen, aber es kann auch als Tutorial verstanden werden für Programmierer, die eher imperative Sprachen kennen.

== Einführung

=== Wieso Funktionale Programmierung?

Funktionale Programmierung ermöglicht es, kurzen deklarativen Programmcode zu schreiben, welcher nur Daten und Funktionen kennt und dafür keine Nebenwirkungen hat. Funktionen einer funktionalen Programmiersprache bekommen einen Input und generieren einen Output, der _nur_ vom Input abhängt und keine inneren Zustände kennt.

*Imperative Programmierung:*

[source,java]
----
var x; //Funktionen können mit den Daten machen, was sie wollen.

f();
g();
----


*Funktionale (deklarative) Programmierung:*
[source, haskell]
----
g(f x); --Daten werden in einem Funktionsfluss transformiert
----

Es gibt einen Programmfluss, welcher durch eine Verkettung von Funktionen ensteht. Die Funktionen sind wie Maschienen, welche mit einem Input einen Output generieren.

image::programmfluss.png[Programmfluss,500,250]

=== Wieso Haskell? 
//image::Haskell-Logo.svg[Haskell,25,25]

Die Funktionale Programmierung ist ein Programmierparadigma, dessen Konzepte auch in bekannten objektorientierten Programmiersprachen wie C# oder Java eingesetzt wird. Haskell ist aber eine pure funktionale Sprache, welche von Grund auf funktional designt wurde. Daher ist sie bestens dafür geeignet, das funktionale Programmieren kompromisslos zu lernen.

=== Setup

*Download der Haskell Plattform:* +
https://www.haskell.org/platform/

Nach der Installation kann in der Kommandozeile `ghci` gestartet werden. GHCI ist die interaktive Umgebung des Haskell Compilers GHC.

Wenn `ghci` gestartet wurde, dann man bereits in der Konsole programmieren, wie mit der `jshell` in Java.

Um Skripte mit dem `.hs` Format zu schreiben, welche man dann kompilieren und ausführen kann, sollte man die folgenden Befehle kennen:

[cols="1,2", options="header"] 
.GHCI Befehle
|===
|Befehl
|Beschreibung

|:?
| Zeigt Hilfstext

|:cd /path/..
|Ändert den Pfad

|:l skript.hs
|Lädt das Skript `skript.hs`

|:r 
|Lädt das aktuelle Skript neu

|:t expr
|Zeigt den Typ einer Expression

|:q
|Beendet die `ghci` Sitzung
|===


== Funktionsdefinition
Um Funktionen definieren zu können, braucht man in Haskell einen Funktionsnamen, Parametertypen und einen Rückgabetyp.

[source,haskell]
----
name :: ParameterType1 -> ParameterType2 -> ... -> ParameterTypeK -> ResultType
name p1 p2 ... pk = e --Result based on parameters
----

*Beispiele*

[source,haskell]
----
verdoppeln :: Integer -> Integer
verdoppeln n = 2*n

addieren :: Integer -> Integer -> Integer
addieren a b = a + b
----

Vergleich mit Java

[source,java]
----
int verdoppeln(int n){
    return 2*n;
}

int addieren(int a, int b){
    return a+b;
}
----

== Typen

=== Was ist ein Typ
Daten sind einfach eine Menge von Bits, welche ohne korrekte Interpretation nutzlos sind. Typen geben diesen einfachen Bits Bedeutung.

Typen stellen sicher, dass auf den Werten von Variablen keine Operationen ausgeführt werden, die syntaktisch oder semantisch fehlerhaft sind und dass diese Werte im definierten Wertebereich sind.

Haskell hat wie Java ein *statisches Typsystem*. JS und Python haben ein dynamisches Typsystem, welches die Typen erst zur Laufzeit prüft.

TIP: Mit `:t` kann man in der ghci den Typ eines Ausdrucks herausfinden. z. B `:t max`

In der Praxis ist es z. T überraschend, wie die Sprachen Ausdrücke interpretieren:

[cols="2,1,1,1,1", options="header"] 
.Typenvergleich
|===
|Ausdruck
|Javascript
|Python
|Java
|Haskell

|`5 + 8`
|`13`
|`13`
|`13`
|`13`

|`5 + "Hallo"`
|``"5Hallo"``
|[red]#Error#
|`"5Hallo"`
|[red]#Error#

|`5 + True`
|`6`
|`6`
|[red]#Error#
|[red]#Error#

|`5 - "2"`
|`3`
|[red]#Error#
|[red]#Error#
|[red]#Error#

|`5 * "1"`
|5
|`11111`
|[red]#Error#
|[red]#Error#

|`False * "Hallo"`
|`NaN`
|""
|[red]#Error#
|[red]#Error#
|===

=== Typen

==== Basic Types

[cols="1,1,1", options="header"] 
.Haskell Typen
|===
|Typ
|Beschreibung
|Wertebereich

|[blue]#Bool#
|Für logische Werte
|True oder False

|[blue]#Char#
|Für Zeichen
|Alle Zeichen

|[blue]#Int#
|Für ganzzahlige Integer
|64 Bit Integer, also -2^63 to 2^63-1

|[blue]#Integer#
|Für alle ganzzahligen Integer. Langsamer, da nicht CPU supportet.
|Kein fixer Wertebereich. Soviel, wie die CPU schafft.

|[blue]#Double#
|Für alle Gleitkommazahlen
|64 Bit Floating Point
|===

==== Enumeration Types
Mit `data` kann man Enumerationen erstellen

[source,haskell]
----
data Color = Red | Yellow | Green deriving (Show) <1>
data ToDo  = Stop | Wait | Go deriving (Show) <2>
----
<1> Enum mit 3 Farben
<2> Enum mit 3 Zuständen


`deriving (Show)` macht das die Werte als `String` zurückgegeben werden können

==== Tuples - Aggregated Types
Tuples sind aggregierte Typen, welche eine endliche Sequenz von Komponenten mit unterschiedlichen Typen beinhaltet.

*Arity* nennt man die Anzahl Komponenten eines Tuples

[source,haskell]
----
(False, 8, "Hallo") <1>
(8, 'a', True, "Text") <2>
((True, `8`), (`e`, False, `x`))
----
<1> Das Tuple hat die Komponententypen `(Bool, Int, String)` und haben eine Arity von 3
<2> Das Tuple hat die Komponententypen `(Int, Char, Bool, String)` und haben eine Arity von 4
<3> Das Tuple hat zwei Tuple als Komponenten mit der Arity von 2

*Zugriff auf Tuple Komponenten* +
Zugreifen kann man mittels Pattern Matching. Darauf wird später eingegangen.

[source,haskell]
----
fstInt :: (Int,Int) -> Int 
fstInt (x, y) = x 

sndInt:: (Int,Int) -> Int
sndInt (x, y) = y
----

==== Polymorphe Typen
Die Funktionen `fstInt` und `sndInt` im letzten Teil funktionieren nur bei 2-Tuplen mit zwei `Int`. Um eine Funktion zu schreiben, welche für alle Typen funktioniert, benötigt man polymorphe Typen:

[source,haskell]
----
fst :: (a,b) -> a <1>
fst (x, y) = x 

snd:: (a,b) -> b
snd (x, y) = y
----
<1> `a` und `b` sind polymorphe Typen

Funktionen wie `fst` und `snd` nenn man *Polymorphe Funktionen*, da sie einen parametrischen Polymorphismus ermöglichen. Mit solchen Funktionen kann man weniger Code mit weniger Typfehleranfälligkeiten schreiben.

==== Typ Synonyme
Mit dem Schlüsselwort `type` kann man einen Typ Synonym erstellen. Dieser ist kein neuer Typ, sondern nur ein neuer Name!

[source,haskell]
----
type Coord = (Int, Int)
----
Hier kann zum Beispiel `Coord` gleich verwendet werden wie ein normales `(Int, Int)` Tuple. Es hilft nur der Leserlichkeit.

==== Record Types

Record Types sind neue eigene Typen die man definieren kann.

[source,haskell]
----
data Person = Person { name :: String , age :: Int } deriving (Show)
----

==== Function Types
Funktionen haben auch einen Typ. Es hat einen Typ für input parameter und für output parameter

[source,haskell]
----
functionname :: Inputtype -> Outputtype
----

==== Type classes

Typklassen sind vergleichbar mit Interfaces in Java oder C#. Wenn ein Typ Teil einer Typklasse ist, dann bedeutet das, dass gewisses Verhalten der Typklasse darin enthalten ist.

Basic Type Classes::
  Eq – equality types:::
    * Contains types whose values can be compared for equality and inequality
    * methods: (==), (/=)
  Ord – ordered types:::
    * Contains types whose values are totally ordered
    * methods: (<), (<=), (>), (>=), min, max
  Show – showable types:::
    * Contains types whose values can be converted into strings of characters
    * method `show : a -> String`
  Num – numeric types:::
    * Contains types whose values are numeric
    * methods: (+), (-), (*), negate, abs, signum
  Integral – integral types:::
    * Contains types that are numeric but of integral value
    * methods: div, mod
  Fractional – fractional types:::
    * Contains types that are numeric but of fractional value
    * methods: (/), recip

NOTE: Alle Operatoren in Haskell sind auch Funktionen, welche infix geschrieben werden können. Wenn man in der ghci den Typ eines Operators anschaut, z. B `:t ==`, dann sieht man die Verwendung der Typklassen.

*Berechnung mit Zahlen* +

Alle Zahlen gehören der Typklasse `Num` an. Dabei sieht die Hierarchie folgendermassen aus:

* `Num`
** `Integral` mit Typen `Int` und `Integer`
** `Fractional` mit dem Typ `Double`

CAUTION: Haskell konvertiert Zahlentypen nicht automatisch

Um Ganzzahlen zu konvertieren, gibt es die hilfreiche Methode: + 
 `fromIntegral :: (Integral a, Num b) => a -> b`

Die Methode `length` zum Beispiel gibt einen `Int` zurück, wenn man dazu `1.1` addieren möchte, dann benötigt man die Funktion `fromIntegral`

[source,haskell]
----
length [1,2,3,4]) + 1.1 <1>

fromIntegral (length [1,2,3,4]) + 1.1 <2>
----
<1> führt zu einem Fehler, da length einen `Int` zurückgibt und 1.1 ein `Double ist`

<2> `fromIntegral` löst das Problem

== Quellen
* http://learnyouahaskell.com/types-and-typeclasses
